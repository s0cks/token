#include "server.h"#include "token.h"#include "common.h"#include "proposer.h"#include "block_chain.h"#include "block_discovery.h"#include "transaction_pool.h"#include "unclaimed_transaction_pool.h"#include "snapshot.h"#include "snapshot_file.h"static inline voidInitializeLogging(char* arg0){    using namespace Token;    google::LogToStderr();    google::InitGoogleLogging(arg0);}class SnapshotIndexPrinter : public Token::SnapshotBlockIndexVisitor{private:    size_t count_ = 1;public:    SnapshotIndexPrinter() = default;    ~SnapshotIndexPrinter() = default;    bool Visit(Token::SnapshotBlockIndex::BlockReference* ref){        LOG(INFO) << " - #" << (count_++) << ": " << (*ref);        return true;    }};class SnapshotBlockDataPrinter : public Token::SnapshotBlockDataVisitor, Token::BlockVisitor{public:    SnapshotBlockDataPrinter() = default;    ~SnapshotBlockDataPrinter() = default;    bool Visit(const Token::Handle<Token::Transaction>& tx){        LOG(INFO) << "     * " << tx->GetHash();        return true;    }    bool Visit(const Token::Handle<Token::Block>& blk){        LOG(INFO) << " - Block #" << blk->GetHeight();        blk->Accept(this);        LOG(INFO) << "";        return true;    }};//TODO:// - create global environment teardown and deconstruct routines// - validity/consistency checks on block chain data// - better merkle tree implementation// - need tech docs for points of interest// - cleanup logs// - more client commands?// - safer/better shutdown/terminate routines// - Snapshots: https://www.geeksforgeeks.org/chandy-lamports-global-state-recording-algorithm/intmain(int argc, char** argv){    using namespace Token;    // Install Signal Handlers    SignalHandlers::Initialize();    // Parse Command Line Arguments    gflags::ParseCommandLineFlags(&argc, &argv, true);    // Initialize the Logging Framework    InitializeLogging(argv[0]);    // Initialize the Allocator    Allocator::Initialize();#ifdef TOKEN_DEBUG    // Print Debug Banner in Logs    std::string header = "Token " + GetVersion() + " Debug Mode Enabled!";    size_t total_size = 50;    size_t middle = (total_size - header.size()) / 2;    std::stringstream ss1;    for(size_t idx = 0; idx < total_size; idx++) ss1 << "#";    std::stringstream ss2;    ss2 << "#";    for(size_t idx = 0; idx < middle; idx++) ss2 << " ";    ss2 << header;    for(size_t idx = 0; idx < middle - 1; idx++) ss2 << " ";    ss2 << "#";    LOG(INFO) << ss1.str();    LOG(INFO) << ss2.str();    LOG(INFO) << ss1.str();#endif //TOKEN_DEBUG    {        Handle<Input> in1 = Input::NewInstance(uint256_t(), 1, "TestUser");        LOG(INFO) << "Input (Pre-Serialization): " << in1;        size_t size = in1->GetBufferSize();        uint8_t* bytes = (uint8_t*)malloc(size);        if(!in1->Encode(bytes))            CrashReport::GenerateAndExit("Couldn't serialize input to byte array");        Handle<Input> in2 = Input::NewInstance(bytes);        LOG(INFO) << "Input (Post-Serialization): " << in2;    }    {        Handle<Output> out1 = Output::NewInstance("TestUser", "TestToken");        LOG(INFO) << "Output (Pre-Serialization): " << out1;        size_t size = out1->GetBufferSize();        uint8_t* bytes = (uint8_t*)malloc(size);        if(!out1->Encode(bytes))            CrashReport::GenerateAndExit("Couldn't serialize output to byte array");        Handle<Output> out2 = Output::NewInstance(bytes);        LOG(INFO) << "Output (Post-Serialization): " << out2;    }    Handle<Block> blk1 = Block::Genesis();    Handle<Transaction> tx1 = blk1->GetTransaction(0);    LOG(INFO) << "Transaction Hash (Pre-Serialization): " << tx1->GetHash();    {        size_t size = tx1->GetBufferSize();        uint8_t* bytes = (uint8_t*)malloc(size);        if(!tx1->Encode(bytes)){            CrashReport::GenerateAndExit("Couldn't serialize transaction to byte array");        }        Handle<Transaction> tx2 = Transaction::NewInstance(bytes);        LOG(INFO) << "Transaction Hash (Post-Serialization): " << tx2->GetHash();    }    LOG(INFO) << "Block Hash (Pre-Serialization): " << blk1->GetSHA256Hash();    {        size_t size = blk1->GetBufferSize();        uint8_t* bytes = (uint8_t*)malloc(size);        if(!blk1->Encode(bytes)){            CrashReport::GenerateAndExit("Couldn't serialize block to byte array");        }        Handle<Block> blk2 = Block::NewInstance(bytes);        LOG(INFO) << "Block Hash (Post-Serialization): " << blk2->GetSHA256Hash();    }    /*    BlockChain::Initialize();    BlockDiscoveryThread::Start();    ProposerThread::Start();    Server::Start();    SnapshotWriter writer;    if(!writer.WriteSnapshot())        CrashReport::GenerateAndExit("Couldn't write new snapshot");    std::string filename = writer.GetFile()->GetFilename();    SnapshotReader reader(filename);    Snapshot* snapshot = nullptr;    if(!(snapshot = reader.ReadSnapshot()))        CrashReport::GenerateAndExit("Couldn't read new snapshot");    LOG(INFO) << "Snapshot Block Index:";    SnapshotIndexPrinter snap_index_printer;    snapshot->GetIndex()->Accept(&snap_index_printer);    LOG(INFO) << "Snapshot Block Data:";    SnapshotBlockDataPrinter snap_block_printer;    snapshot->Accept(&snap_block_printer);#ifdef TOKEN_DEBUG    //LOG(INFO) << "Unclaimed Transaction Pool:";    //UnclaimedTransactionPool::PrintUnclaimedTransactions();    //LOG(INFO) << "Block Chain:";    //BlockChain::PrintBlockChain();#endif//TOKEN_DEBUG    sleep(30);//------------------------------------------------------------------------------// Test Code/*    LOG(INFO) << "getting unclaimed transactions";    std::vector<uint256_t> utxos;    if(!UnclaimedTransactionPool::GetUnclaimedTransactions(utxos)){        LOG(ERROR) << "couldn't get unclaimed transactions for: TestUser";        return EXIT_FAILURE;    }    uint32_t idx = 0;    for(auto& it : utxos){        LOG(INFO) << "spending token: " << it;        UnclaimedTransaction* utxo = UnclaimedTransactionPool::GetUnclaimedTransaction(it);        Input* inputs[1] = {            Input::NewInstance(utxo->GetTransaction(), utxo->GetIndex(), utxo->GetUser())        };        Output* outputs[1] = {            Output::NewInstance("TestUser2", "TestToken2")        };        Transaction* tx = Transaction::NewInstance(idx++, inputs, 1, outputs, 1);        TransactionPool::PutTransaction(tx);        if(idx == 2) break;    }*///----------------------------------------------------------------------------------    Server::WaitForState(Server::kStopped);    BlockDiscoveryThread::WaitForState(BlockDiscoveryThread::kStopped);    return EXIT_SUCCESS;}