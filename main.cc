#include <sstream>#include <string>#include <glog/logging.h>#include <sys/stat.h>#include "common.h"#include "keychain.h"#include "block_chain.h"#include "node/node.h"#include "service/service.h"static inline boolFileExists(const std::string& name){    std::ifstream f(name.c_str());    return f.good();}static inline boolInitializeLogging(char* arg0){    std::string path = (TOKEN_BLOCKCHAIN_HOME + "/logs/");    if(!FileExists(path)){        int rc;        if((rc = mkdir(path.c_str(), S_IRWXU|S_IRWXG|S_IROTH|S_IXOTH)) == -1){            std::cerr << "Couldn't initialize logging directory '" << path << "'..." << std::endl;            return false;        }    }    google::SetLogDestination(google::INFO, path.c_str());    google::SetLogDestination(google::WARNING, path.c_str());    google::SetLogDestination(google::ERROR, path.c_str());    google::SetStderrLogging(google::INFO);    google::InitGoogleLogging(arg0);    return true;}bool GetPeers(const std::string str, std::vector<std::string>& peers){    std::stringstream ss(str);    std::string token;    while (std::getline(ss, token, ',')) {        peers.push_back(token);    }    return peers.size() > 0;}intmain(int argc, char** argv){    using namespace Token;    gflags::ParseCommandLineFlags(&argc, &argv, true);    if(!InitializeLogging(argv[0])){        fprintf(stderr, "Couldn't initialize logging!"); //TODO: Refactor        return EXIT_FAILURE;    }    if(!TokenKeychain::InitializeKeys()){        LOG(ERROR) << "couldn't initialize keychain";        return EXIT_FAILURE;    }    {        // Load the UnclaimedTransactionPool into memory        if(!Token::UnclaimedTransactionPool::LoadUnclaimedTransactionPool()){            LOG(ERROR) << "couldn't initialize the UnclaimedTransactionPool";            return EXIT_FAILURE;        }        if(TOKEN_VERBOSE){            //TODO: Print UTXO Pool        }    }    {        // Load the TransactionPool into memory        if(!TransactionPool::Initialize()){            LOG(ERROR) << "couldn't initialize the TransactionPool";            return EXIT_FAILURE;        }        if(TOKEN_VERBOSE){            //TODO: TransactionPoolPrinter::PrintAsInfo();        }    }    {        // Load the BlockChain into memory        if(!BlockChain::Initialize()){            LOG(ERROR) << "couldn't initialize the BlockChain";            return EXIT_FAILURE;        }        if(TOKEN_VERBOSE){            // TODO: BlockChainPrinter::PrintAsInfo(Printer::kDetailed);        }    }    if(TOKEN_VERBOSE){        Block* head = BlockChain::GetHead();        LOG(INFO) << "Head := #" << head->GetHeight() << " " << head->GetHash();    }    if(FLAGS_port > 0){        BlockChainNode::Initialize("localhost", FLAGS_port);        if(!FLAGS_peers.empty()){            std::vector<std::string> peerlist;            if(FLAGS_peers.find(",") != std::string::npos){                if(!GetPeers(FLAGS_peers, peerlist)){                    LOG(ERROR) << "couldn't decode peers: " << FLAGS_peers;                    return EXIT_FAILURE;                }            } else{                peerlist.push_back(FLAGS_peers);            }            for(auto& it : peerlist){                BlockChainNode::GetInstance()->Connect(it, 8080);            }        }    }    if(FLAGS_service_port > 0){        BlockChainService::Start("localhost", FLAGS_service_port);        LOG(INFO) << "BlockChainService started @ localhost:" << FLAGS_service_port;        BlockChainService::WaitForShutdown();    }    if(FLAGS_port > 0){        BlockChainNode::WaitForShutdown();    }    return EXIT_SUCCESS;}