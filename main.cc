#include "node/node.h"#include "node/session.h"#include "common.h"#include "bloom.h"#include "crash_report.h"#include "block_chain.h"#include "block_miner.h"#ifdef TOKEN_HEALTHCHECK_SUPPORT#include "http/server.h"#endif//TOKEN_HEALTHCHECK_SUPPORTstatic inline voidInitializeLogging(char* arg0){    using namespace Token;    if(!FileExists(FLAGS_path)){        if(!CreateDirectory(FLAGS_path)){            std::stringstream ss;            ss << "Couldn't initialize the block chain directory: " << FLAGS_path;            CrashReport::GenerateAndExit(ss);        }    }    std::string path = (TOKEN_BLOCKCHAIN_HOME + "/logs/");    if(!FileExists(path)){        if(!CreateDirectory(path)){            std::stringstream ss;            ss << "Couldn't initialize the logging directory: " << path;            CrashReport::GenerateAndExit(ss);        }    }    google::SetLogDestination(google::INFO, path.c_str());    google::SetLogDestination(google::WARNING, path.c_str());    google::SetLogDestination(google::ERROR, path.c_str());    google::SetStderrLogging(google::INFO);    google::InitGoogleLogging(arg0);}//TODO:// - create global environment teardown and deconstruct routines// - validity/consistency checks on block chain data// - better merkle tree implementation// - monitoring functionality?// - initialize node info// - need tech docs for points of interest// - cleanup logsintmain(int argc, char** argv){    using namespace Token;    // 1. Install Signal Handlers    SignalHandlers::Initialize();    // 2. Parse Command Line Arguments    gflags::ParseCommandLineFlags(&argc, &argv, true);    // 3. Initialize Logging    InitializeLogging(argv[0]);#ifdef TOKEN_DEBUG    // Print Debug Banner in Logs    std::string header = "Token " + GetVersion() + " Debug Mode Enabled!";    size_t total_size = 50;    size_t middle = (total_size - header.size()) / 2;    std::stringstream ss1;    for(size_t idx = 0; idx < total_size; idx++) ss1 << "#";    std::stringstream ss2;    ss2 << "#";    for(size_t idx = 0; idx < middle; idx++) ss2 << " ";    ss2 << header;    for(size_t idx = 0; idx < middle - 1; idx++) ss2 << " ";    ss2 << "#";    LOG(INFO) << ss1.str();    LOG(INFO) << ss2.str();    LOG(INFO) << ss1.str();#endif //TOKEN_DEBUG    // 4. Initialize the Block Chain Phase    BlockChain::Initialize();    // 5. Start the Block Miner Thread    BlockMiner::Initialize();    // 6. Optionally start the Block Chain Server Thread    if(FLAGS_port > 0) Node::Start();    if(FLAGS_peer_port > 0){        NodeAddress paddress(FLAGS_peer_address, FLAGS_peer_port);        if(!Node::HasPeer(paddress)){            if(!Node::ConnectTo(paddress)){                std::stringstream ss;                ss << "Couldn't connect to peer: " << paddress;                CrashReport::GenerateAndExit(ss);            }        }    }    // 7. Optionally start the Health Check Server Thread#ifdef TOKEN_HEALTHCHECK_SUPPORT    BlockChainHttpServer::StartServer();#endif//TOKEN_HEALTHCHECK_SUPPORT//------------------------------------------------------------------------------// Test Code/*    LOG(INFO) << "getting unclaimed transactions";    std::vector<uint256_t> utxos;    if(!UnclaimedTransactionPool::GetUnclaimedTransactions(utxos)){        LOG(ERROR) << "couldn't get unclaimed transactions for: TestUser";        return EXIT_FAILURE;    }    uint32_t idx = 0;    for(auto& it : utxos){        LOG(INFO) << "spending token: " << it;        UnclaimedTransaction* utxo = UnclaimedTransactionPool::GetUnclaimedTransaction(it);        Transaction::InputList inputs = {            Input(utxo->GetTransaction(), utxo->GetIndex(), utxo->GetUser()),        };        Transaction::OutputList outputs = {            Output("TestUser2", "TestToken2")        };        Transaction* tx = Transaction::NewInstance(idx++, inputs, outputs);        TransactionPool::PutTransaction(tx);    }*///----------------------------------------------------------------------------------    // 8. Shutdown the Block Chain Server Thread    Node::WaitForShutdown();    // 9. Shutdown the Block Miner Thread    BlockMiner::WaitForStoppedState();    return EXIT_SUCCESS;}