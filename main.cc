#include "node/node.h"#include "node/session.h"#include "common.h"#include "crash_report.h"#include "block_chain.h"#include "block_miner.h"static inline boolInitializeLogging(char* arg0){    using namespace Token;    std::string path = (TOKEN_BLOCKCHAIN_HOME + "/logs/");    if(!FileExists(path)){        int rc;        if((rc = mkdir(path.c_str(), S_IRWXU|S_IRWXG|S_IROTH|S_IXOTH)) == -1){            std::cerr << "Couldn't initialize logging directory '" << path << "'..." << std::endl;            return false;        }    }    google::SetLogDestination(google::INFO, path.c_str());    google::SetLogDestination(google::WARNING, path.c_str());    google::SetLogDestination(google::ERROR, path.c_str());    google::SetStderrLogging(google::INFO);    google::InitGoogleLogging(arg0);    return true;}//TODO:// - organize startup process// - create global environment teardown and deconstruct routines// - validity/consistency checks on block chain data//TODO:// - better merkle tree implementation// - monitoring functionality?intmain(int argc, char** argv){    using namespace Token;    SignalHandlers::Initialize();    gflags::ParseCommandLineFlags(&argc, &argv, true);    if(!FileExists(FLAGS_path)){        if(!CreateDirectory(FLAGS_path)){            std::stringstream ss;            ss << "Couldn't initialize the block chain directory: " << FLAGS_path;            return CrashReport::GenerateAndExit(ss.str());        }    }    if(!InitializeLogging(argv[0])) return CrashReport::GenerateAndExit("Couldn't initialize logging");#if defined(TOKEN_ENABLE_DEBUG)    std::string header = "Token Debug Mode Enabled!";    size_t total_size = 50;    size_t middle = (total_size - header.size()) / 2;    std::stringstream ss1;    for(size_t idx = 0; idx < total_size; idx++) ss1 << "#";    std::stringstream ss2;    ss2 << "#";    for(size_t idx = 0; idx < middle; idx++) ss2 << " ";    ss2 << header;    for(size_t idx = 0; idx < middle - 1; idx++) ss2 << " ";    ss2 << "#";    LOG(INFO) << ss1.str();    LOG(INFO) << ss2.str();    LOG(INFO) << ss1.str();#endif //TOKEN_ENABLE_DEBUG    if(!BlockChain::Initialize()) return CrashReport::GenerateAndExit("Couldn't initialize the BlockChain");    if(!BlockMiner::Initialize()) return CrashReport::GenerateAndExit("Couldn't initialize the Block Miner Thread");    if(FLAGS_port > 0){        if(!Node::Start()){            LOG(ERROR) << "couldn't start BlockChain server";            return EXIT_FAILURE;        }        if(!FLAGS_peer_address.empty()){            NodeAddress paddr(FLAGS_peer_address, FLAGS_peer_port);            if(!Node::ConnectTo(paddr)){                LOG(ERROR) << "couldn't connect to peer: " << paddr;                return EXIT_FAILURE;            }        }    }    //TODO: initialize node info    //TODO: need tech docs for points of interest    sleep(10);    std::vector<uint256_t> utxos;    if(!UnclaimedTransactionPool::GetUnclaimedTransactions(utxos)){        LOG(ERROR) << "couldn't get unclaimed transactions for: TestUser";        return EXIT_FAILURE;    }    Token::UnclaimedTransaction* utxo1;    if(!(utxo1 = UnclaimedTransactionPool::GetUnclaimedTransaction(utxos[0]))){        LOG(ERROR) << "couldn't get unclaimed transaction: " << utxos[0];        return EXIT_FAILURE;    }    Token::UnclaimedTransaction* utxo2;    if(!(utxo2 = UnclaimedTransactionPool::GetUnclaimedTransaction(utxos[1]))){        LOG(ERROR) << "couldn't get unclaimed transaction: " << utxos[1];        return EXIT_FAILURE;    }    Transaction::InputList tx1_inputs = {        Input(utxo1->GetTransaction(), utxo1->GetIndex(), utxo1->GetUser()),    };    Transaction::OutputList tx1_outputs = {        Output("TestUser", "TestToken"),    };    Transaction* tx1 = Transaction::NewInstance(0, tx1_inputs, tx1_outputs);    Allocator::AddRoot(tx1);    if(!TransactionPool::AddTransaction(tx1)){        LOG(WARNING) << "couldn't put transaction #1 into tx pool: " << tx1->GetHash();        return EXIT_FAILURE;    }    Transaction::InputList tx2_inputs = {        Input(utxo2->GetTransaction(), utxo2->GetIndex(), utxo2->GetUser()),    };    Transaction::OutputList tx2_outputs = {        Output("TestUser", "TestToken"),    };    Transaction* tx2 = Transaction::NewInstance(1, tx2_inputs, tx2_outputs);    Allocator::AddRoot(tx2);    if(!TransactionPool::AddTransaction(tx2)){        LOG(WARNING) << "couldn't put transaction #2 into tx pool: " << tx2->GetHash();        return EXIT_FAILURE;    }    /*    //TODO: handle server + rpc start/stop better    if(!BlockChainHttpServer::StartServer()){        LOG(ERROR) << "couldn't start http server...";        return EXIT_FAILURE;    }    */    sleep(20);//CrashReport::GenerateAndExit("Test");    Node::WaitForShutdown();    BlockMiner::WaitForShutdown();    return EXIT_SUCCESS;}